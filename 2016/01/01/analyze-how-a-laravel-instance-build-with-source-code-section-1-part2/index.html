<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="laravel,php,sourcecode," />










<meta name="description" content="在结合源码分析Laravel单个HTTP请求生命周期[part 1]中我们大致分析了laravel处理一次http请求的流程，让laravel初学者能对laravel的生命周期有个初步的认识，但是由于篇幅和时间的问题，其中一些具体的实现我一笔带过，在part2中，我今天来分析一下一个laravel实例，也就是入口文件中">
<meta name="keywords" content="laravel,php,sourcecode">
<meta property="og:type" content="article">
<meta property="og:title" content="结合源码分析laravel实例$app是怎么一步步构建的(上)[part 2]">
<meta property="og:url" content="https://coder-wen.github.io/2016/01/01/analyze-how-a-laravel-instance-build-with-source-code-section-1-part2/index.html">
<meta property="og:site_name" content="coderwen的踩坑日记">
<meta property="og:description" content="在结合源码分析Laravel单个HTTP请求生命周期[part 1]中我们大致分析了laravel处理一次http请求的流程，让laravel初学者能对laravel的生命周期有个初步的认识，但是由于篇幅和时间的问题，其中一些具体的实现我一笔带过，在part2中，我今天来分析一下一个laravel实例，也就是入口文件中的$app是怎么一步步构建的。 温馨提示，本文篇幅较长。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://www.alwayscoder.com/wp-content/uploads/2015/12/ServiceProviders.jpg">
<meta property="og:image" content="https://www.alwayscoder.com/wp-content/uploads/2015/12/offsetGet.jpg">
<meta property="og:updated_time" content="2017-11-28T15:46:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="结合源码分析laravel实例$app是怎么一步步构建的(上)[part 2]">
<meta name="twitter:description" content="在结合源码分析Laravel单个HTTP请求生命周期[part 1]中我们大致分析了laravel处理一次http请求的流程，让laravel初学者能对laravel的生命周期有个初步的认识，但是由于篇幅和时间的问题，其中一些具体的实现我一笔带过，在part2中，我今天来分析一下一个laravel实例，也就是入口文件中的$app是怎么一步步构建的。 温馨提示，本文篇幅较长。">
<meta name="twitter:image" content="https://www.alwayscoder.com/wp-content/uploads/2015/12/ServiceProviders.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://coder-wen.github.io/2016/01/01/analyze-how-a-laravel-instance-build-with-source-code-section-1-part2/"/>





  <title>结合源码分析laravel实例$app是怎么一步步构建的(上)[part 2] | coderwen的踩坑日记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">coderwen的踩坑日记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">闷声学技术，比西方记者快，比华莱士高</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://coder-wen.github.io/2016/01/01/analyze-how-a-laravel-instance-build-with-source-code-section-1-part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="coderwen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="coderwen的踩坑日记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">结合源码分析laravel实例$app是怎么一步步构建的(上)[part 2]</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-01T22:11:33+08:00">
                2016-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/laravel/" itemprop="url" rel="index">
                    <span itemprop="name">laravel</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/laravel/php/" itemprop="url" rel="index">
                    <span itemprop="name">php</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在<a href="https://www.alwayscoder.com/analyze-laravel-request-lifecycle-with-source-code-part-1/" target="_blank" rel="noopener">结合源码分析Laravel单个HTTP请求生命周期[part 1]</a>中我们大致分析了laravel处理一次http请求的流程，让laravel初学者能对laravel的生命周期有个初步的认识，但是由于篇幅和时间的问题，其中一些具体的实现我一笔带过，在part2中，我今天来分析一下一个laravel实例，也就是入口文件中的$app是怎么一步步构建的。</p>
<p><strong>温馨提示，本文篇幅较长。</strong><br><a id="more"></a><br>在<a href="https://www.alwayscoder.com/analyze-laravel-request-lifecycle-with-source-code-part-1/" target="_blank" rel="noopener">part1</a>中我们知道$app实例化以及绑定3大重要组件都是在bootstrap/app.php中进行的，我们先从它的实例化下手</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> Illuminate\Foundation\Application(</span><br><span class="line">    realpath(<span class="keyword">__DIR__</span>.<span class="string">'/../'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在看构造函数前，我们先看看Application是个什么来头</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Container</span> <span class="keyword">implements</span> <span class="title">ApplicationContract</span>, <span class="title">HttpKernelInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *.........</span></span><br><span class="line"><span class="comment">       *.........</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，Application自身就是一个巨大的容器，可能你读到这还不知道容器是干嘛的，先不急，但是你先记住<strong>容器是laravel的心脏</strong></p>
<p>我们跳到Application的构造函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new Illuminate application instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string|null  $basePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span>  <span class="title">__construct</span><span class="params">($basePath = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;registerBaseBindings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;registerBaseServiceProviders();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;registerCoreContainerAliases();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($basePath) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;setBasePath($basePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从函数名可以看出，Application的构造函数主要干了四件事，注册基础绑定，注册基础服务提供者，注册核心容器的别名（翻译不是很准确，欢迎指正）以及设置整个app的路径</p>
<p>我们一个一个来<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the basic bindings into the container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerBaseBindings</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>::setInstance(<span class="keyword">$this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'app'</span>, <span class="keyword">$this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;instance(<span class="string">'Illuminate\Container\Container'</span>, <span class="keyword">$this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先调用了静态函数setInstance，通过代码跟踪，这个函数是Container的一个函数，代码如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the shared instance of the container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  \Illuminate\Contracts\Container\Container  $container</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">setInstance</span><span class="params">(ContainerContract $container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>::$instance = $container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看注释理解很容易，设置一个共享的容器实例，在application中调用时传入了$this，毫无疑问，这个共享的容器实例就是laravel实例本身，它作为一个容器，为实现DI(依赖注入)担负着巨大的责任</p>
<p>看看Container对静态成员变量$instance的声明，这是一个全局可用的容器，为什么说if any呢，整个项目当然不止application一个容器了<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The current globally available container (if any).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> static</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> $instance;`</span><br></pre></td></tr></table></figure></p>
<p>接着registerBaseBindings这个函数，它连续调用两次instance函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;instance(<span class="string">'app'</span>, <span class="keyword">$this</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;instance(<span class="string">'Illuminate\Container\Container'</span>, <span class="keyword">$this</span>);</span><br></pre></td></tr></table></figure>
<p>instance同样也是Container下声明的一个函数 <strong>注:为了节省篇幅我删除了一些空行</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register an existing instance as shared in the container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  mixed   $instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">instance</span><span class="params">($abstract, $instance)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// First, we will extract the alias from the abstract if it is an array so we</span></span><br><span class="line">    <span class="comment">// are using the correct name when binding the type. If we get an alias it</span></span><br><span class="line">    <span class="comment">// will be registered with the container so we can resolve it out later.</span></span><br><span class="line">    <span class="keyword">if</span> (is_array($abstract)) &#123;</span><br><span class="line">        <span class="keyword">list</span>($abstract, $alias) = <span class="keyword">$this</span>-&gt;extractAlias($abstract);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;alias($abstract, $alias);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;aliases[$abstract]);</span><br><span class="line">    <span class="comment">// We'll check to determine if this type has been bound before, and if it has</span></span><br><span class="line">    <span class="comment">// we will fire the rebound callbacks registered with the container and it</span></span><br><span class="line">    <span class="comment">// can be updated with consuming classes that have gotten resolved here.</span></span><br><span class="line">    $bound = <span class="keyword">$this</span>-&gt;bound($abstract);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;instances[$abstract] = $instance;</span><br><span class="line">    <span class="keyword">if</span> ($bound) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;rebound($abstract);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从phpdoc我们可以大概得知该函数的作用:把一个存在的实例注册到容器中，具体过程如下<br>首先判断$abstract抽象体是否是个数组，如果是，我们就将数组拆成键值对拿到$abstract和它的别名，并将它们通过alias函数将它们以<br>aliases[$alias] = $abstract的形式放到aliases数组里面方便以后查找，然后删除alias数组中以$abstract为键的项以免接下来的绑定判断出现问题<br>接着检查这个$abstract之前是否被绑定过，bound方法也很简单</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if the given abstract type has been bound.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bound</span><span class="params">($abstract)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;bindings[$abstract]) || <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;instances[$abstract]) || <span class="keyword">$this</span>-&gt;isAlias($abstract);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三者任一为真则已经绑定过，这时我们才把$abstract放到instances数组里，如果该抽象体之前被绑定过那么我们需要通过rebound方法调用之前在容器注册的rebound回调函数，抽象体可以通过这种方法更新，因为app 和 container的第一次instance所以不存在rebound的情况，这次我们就不跟进去了</p>
<p>回到构造函数的第二个调用<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;registerBaseServiceProviders();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register all of the base service providers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">registerBaseServiceProviders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> EventServiceProvider(<span class="keyword">$this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;register(<span class="keyword">new</span> RoutingServiceProvider(<span class="keyword">$this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看代码前我们先搞清楚，service provider 即服务提供者是个什么东西，我们看看<a href="https://laravel.com/docs/5.2/providers#introduction" target="_blank" rel="noopener">官方的定义</a></p>
<hr>
<blockquote>
<p>Service providers are the central place of all Laravel application bootstrapping. Your own application, as well as all of Laravel’s core services are bootstrapped via service providers.<br>But, what do we mean by “bootstrapped”? In general, we mean <strong>registering</strong> things, including registering service container bindings, event listeners, middleware, and even routes. Service providers are the central place to configure your application.<br>If you open the <code>app.php</code> file included with Laravel, you will see a <code>providers</code> array. These are all of the service provider classes that will be loaded for your application. Of course, many of them are “deferred” providers, meaning they will not be loaded on every request, but only when the services they provide are actually needed.</p>
</blockquote>
<hr>
<p>我觉得service provider干的事 就是注册服务需要的组件，当这些组件需要时容器能很容易地把他们解析出来</p>
<p>我们看看helloworld中有多少service provider的子类，长长的列表足以证明service provider在laravel框架中的重要性</p>
<p><a href="https://www.alwayscoder.com/wp-content/uploads/2015/12/ServiceProviders.jpg" target="_blank" rel="noopener"><img src="https://www.alwayscoder.com/wp-content/uploads/2015/12/ServiceProviders.jpg" alt="service provider的子类"></a></p>
<p><a href="https://laravel.com/docs/5.2/providers" target="_blank" rel="noopener">官方文档</a>对service provider有详细的介绍，我也不再赘述</p>
<p>现在我们看看两次传进去的service provider构造函数分别干了什么，其实两者都没重写构造函数，所以构造函数都是基类ServiceProvider的</p>
<p>构造函数就一句话：注入了当前laravel的实例<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new service provider instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  \Illuminate\Contracts\Foundation\Application  $app</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($app)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app = $app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此得到了两个service Provider的子类实例，传入register函数进行注册<br>一步步看register干了什么才能将两个service provider 成功注册<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a service provider with the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  \Illuminate\Support\ServiceProvider|string  $provider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array  $options</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  bool   $force</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Support\ServiceProvider</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">($provider, $options = [], $force = false)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($registered = <span class="keyword">$this</span>-&gt;getProvider($provider) &amp;amp;&amp;amp; ! $force) &#123;</span><br><span class="line">        <span class="keyword">return</span> $registered;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the given "provider" is a string, we will resolve it, passing in the</span></span><br><span class="line">    <span class="comment">// application instance automatically for the developer. This is simply</span></span><br><span class="line">    <span class="comment">// a more convenient way of specifying your service provider classes.</span></span><br><span class="line">    <span class="keyword">if</span> (is_string($provider)) &#123;</span><br><span class="line">        $provider = <span class="keyword">$this</span>-&gt;resolveProviderClass($provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $provider-&gt;register();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once we have registered the service we will iterate through the options</span></span><br><span class="line">    <span class="comment">// and set each of them on the application so they will be available on</span></span><br><span class="line">    <span class="comment">// the actual loading of the service objects and for developer usage.</span></span><br><span class="line">    <span class="keyword">foreach</span> ($options <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">        <span class="keyword">$this</span>[$key] = $value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;markAsRegistered($provider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the application has already booted, we will call this boot method on</span></span><br><span class="line">    <span class="comment">// the provider class so it has an opportunity to do its boot logic and</span></span><br><span class="line">    <span class="comment">// will be ready for any usage by the developer's application logics.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;booted) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;bootProvider($provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断了该provider是否被注册过，如果注册且不是强制注册则返回之前的实例<br>我们先看看getProvider怎么判断当前provider是否注册过，如果你不感兴趣，可以跳过这一节<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the registered service provider instance if it exists.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  \Illuminate\Support\ServiceProvider|string  $provider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Support\ServiceProvider|null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getProvider</span><span class="params">($provider)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $name = is_string($provider) ? $provider : get_class($provider);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arr::first(<span class="keyword">$this</span>-&gt;serviceProviders, <span class="function"><span class="keyword">function</span> <span class="params">($key, $value)</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $value <span class="keyword">instanceof</span> $name;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断了传入的provider是字符串还是类，如果是类的话我们取其类名，接着调用了laravel内置的帮助函数Arr:first，传入了两个参数，一个是当前注册过的serviceProviders数组，第二个是匿名函数，通过判断$value是否是$name的实例来返回布尔值</p>
<p>再看看Arr:first<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the first element in an array passing a given truth test.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array  $array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable  $callback</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  mixed  $default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">first</span><span class="params">($array, callable $callback, $default = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($array <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (call_user_func($callback, $key, $value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> $value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value($default);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑非常清晰，first()通过foreach遍历serviceProviders数组，使用迭代出的键值对传入作为第二参数的回调函数，即刚才的匿名函数，如果有任一一次回调函数返回真，则返回真跳出，如果遍历完还是没真，就返回默认值，私以为getProvider调用可以加上默认参数false，毕竟最后返回的是布尔值，而$default的默认值是null，扯远了，回到register函数这来</p>
<p>接着register判断了给的$provider是否是字符串，如果是的话还得把实体给解析出来，不然没法调用$provider-&gt;register()<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_string($provider)) &#123;</span><br><span class="line">                $provider = <span class="keyword">$this</span>-&gt;resolveProviderClass($provider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们现在传进来的是个实例，至于通过字符串解析出实体就是return new $provider($this)简单实现</p>
<p>接着调用了$provider实体最重要的register方法，其实大家查看service provider的源码就知道在ServiceProvider抽象类定义的同时也定义了register这个抽象方法，通过调用它，service provider将其相关的逻辑都注册完成</p>
<p>接着将options写进实例<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Once we have registered the service we will iterate through the options</span></span><br><span class="line"><span class="comment">// and set each of them on the application so they will be available on</span></span><br><span class="line"><span class="comment">// the actual loading of the service objects and for developer usage.</span></span><br><span class="line"><span class="keyword">foreach</span> ($options <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">    <span class="keyword">$this</span>[$key] = $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果有传入options，我们迭代将其键值对放入application供需要时调用</p>
<p>接下来调用markAsRegistered方法将该provider标记为已注册，我们看看它的实现<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mark the given provider as registered.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  \Illuminate\Support\ServiceProvider  $provider</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">markAsRegistered</span><span class="params">($provider)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>[<span class="string">'events'</span>]-&gt;fire($class = get_class($provider), [$provider]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;serviceProviders[] = $provider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;loadedProviders[$class] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一行乍看有点蒙，至少我开始看时蒙了，虽然写程序的时候我知道可以通过app(‘url’)拿到url的实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; app(<span class="string">'url'</span>)</span><br><span class="line">=&gt; Illuminate\Routing\UrlGenerator &#123;<span class="comment">#103&#125;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>想必$this-&gt;[‘events’]是一样的，但是实现原理还是不太清楚，打个断点一目了然</p>
<p><a href="https://www.alwayscoder.com/wp-content/uploads/2015/12/offsetGet.jpg" target="_blank" rel="noopener"><img src="https://www.alwayscoder.com/wp-content/uploads/2015/12/offsetGet.jpg" alt="offsetGet"></a></p>
<p>Container容器通过实现了php原生ArrayAccess接口的offsetGet函数,提供了对容器的下标访问方法</p>
<p>所以$this[‘events’]等于$this-&gt;make(‘events’)，没记错的话events就是EventServiceProvider实例作为参数时调用register函数绑定的</p>
<p>我还是上一下代码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the service provider.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'events'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Dispatcher($app))-&gt;setQueueResolver(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($app)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> $app-&gt;make(<span class="string">'Illuminate\Contracts\Queue\Factory'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在要make(‘events’)，怎么个make法，”大变活人”之字符串new对象即将上演，各位看官拭目以待</p>
<p>先看看make函数的实现<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve the given type from the container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array   $parameters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">($abstract, array $parameters = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $abstract = <span class="keyword">$this</span>-&gt;getAlias($abstract);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an instance of the type is currently being managed as a singleton we'll</span></span><br><span class="line">    <span class="comment">// just return an existing instance instead of instantiating new instances</span></span><br><span class="line">    <span class="comment">// so the developer can keep using the same objects instance every time.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;instances[$abstract])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;instances[$abstract];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $concrete = <span class="keyword">$this</span>-&gt;getConcrete($abstract);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're ready to instantiate an instance of the concrete type registered for</span></span><br><span class="line">    <span class="comment">// the binding. This will instantiate the types, as well as resolve any of</span></span><br><span class="line">    <span class="comment">// its "nested" dependencies recursively until all have gotten resolved.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isBuildable($concrete, $abstract)) &#123;</span><br><span class="line">        $object = <span class="keyword">$this</span>-&gt;build($concrete, $parameters);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $object = <span class="keyword">$this</span>-&gt;make($concrete, $parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we defined any extenders for this type, we'll need to spin through them</span></span><br><span class="line">    <span class="comment">// and apply them to the object being built. This allows for the extension</span></span><br><span class="line">    <span class="comment">// of services, such as changing configuration or decorating the object.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;getExtenders($abstract) <span class="keyword">as</span> $extender) &#123;</span><br><span class="line">        $object = $extender($object, <span class="keyword">$this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the requested type is registered as a singleton we'll want to cache off</span></span><br><span class="line">    <span class="comment">// the instances in "memory" so we can return it later without creating an</span></span><br><span class="line">    <span class="comment">// entirely new instance of an object on each subsequent request for it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isShared($abstract)) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;instances[$abstract] = $object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;fireResolvingCallbacks($abstract, $object);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;resolved[$abstract] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看注释的行数就知道有点复杂，我们还是一步一个脚印</p>
<p>首先如果$abstract有别名则把它变成别名，接着查看instances数组里面是否有该实例，如果有说明该实例是单例共享模式，我们不用重新make这个实例，直接返回该实例</p>
<p>接着我们通过getConcrete函数拿到$abstract的实体，什么是实体呢，多说无益，看完getConcrete函数你应该就懂了<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the concrete type for a given abstract.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed   $concrete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getConcrete</span><span class="params">($abstract)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! is_null($concrete = <span class="keyword">$this</span>-&gt;getContextualConcrete($abstract))) &#123;</span><br><span class="line">        <span class="keyword">return</span> $concrete;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't have a registered resolver or concrete for the type, we'll just</span></span><br><span class="line">    <span class="comment">// assume each type is a concrete name and will attempt to resolve it as is</span></span><br><span class="line">    <span class="comment">// since the container should be able to resolve concretes automatically.</span></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;bindings[$abstract])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;missingLeadingSlash($abstract) &amp;amp;&amp;amp;</span><br><span class="line">            <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;bindings[<span class="string">'\\'</span>.$abstract])) &#123;</span><br><span class="line">            $abstract = <span class="string">'\\'</span>.$abstract;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $abstract;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;bindings[$abstract][<span class="string">'concrete'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断$abstact是否有上下文相关的实体，如果有直接返回，你可能要问了什么是上下文相关的实体呢</p>
<p>大家看下官方文档<a href="https://laravel.com/docs/5.2/container#contextual-binding" target="_blank" rel="noopener">contextual-binding</a>这一小节就清楚了</p>
<p>如果没有呢，往下面走，如果bindings数组中没有记录针对$abstract的一个绑定，我们就可以认为这个$abstract暂时不能解析，暂时直接返回等以后Container能够解析后再解析，当然如果有对应实体的话我们直接通过$this-&gt;bindings[$abstract][‘concrete’]返回对应绑定实体，通过刚才的分析我们知道：绑定实体并不意味着就是实例，可以是一个闭包函数,还可能是一个字符串</p>
<p>回到make函数来<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We're ready to instantiate an instance of the concrete type registered for</span></span><br><span class="line"><span class="comment">// the binding. This will instantiate the types, as well as resolve any of</span></span><br><span class="line"><span class="comment">// its "nested" dependencies recursively until all have gotten resolved.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isBuildable($concrete, $abstract)) &#123;</span><br><span class="line">    $object = <span class="keyword">$this</span>-&gt;build($concrete, $parameters);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    $object = <span class="keyword">$this</span>-&gt;make($concrete, $parameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着make函数判断刚才拿到的$concrete是否能实例化，判断很简单，我就不贴代码了，如果$concrete和$abstract完全一样或者$concrete是个闭包函数则认为是可实例化的,如果不能实例化呢，说明还有依赖，为了解决嵌套依赖我们继续递归调用make函数直到解决所有嵌套依赖，所以不管有多少依赖最后都会落在build函数上来完成实例化，所以接下来我们要看看build函数的实现</p>
<p><strong>由于篇幅太长，我决定把这篇拆成两篇来写，上半章暂时写到这。</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/laravel/" rel="tag"># laravel</a>
          
            <a href="/tags/php/" rel="tag"># php</a>
          
            <a href="/tags/sourcecode/" rel="tag"># sourcecode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/23/analyze-laravel-request-lifecycle-with-source-code-part-1/" rel="next" title="结合源码分析laravel单个HTTP请求生命周期[part 1]">
                <i class="fa fa-chevron-left"></i> 结合源码分析laravel单个HTTP请求生命周期[part 1]
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/01/02/analyze-how-a-laravel-instance-build-with-source-code-section-2-part2/" rel="prev" title="结合源码分析Laravel实例$App是怎么一步步构建的(下)[part 2]">
                结合源码分析Laravel实例$App是怎么一步步构建的(下)[part 2] <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">coderwen</p>
              <p class="site-description motion-element" itemprop="description">闷声学技术，比西方记者快，比华莱士高</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">coderwen</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
